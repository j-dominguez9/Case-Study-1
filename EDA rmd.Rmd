---
title: "Case Study 1"
author: "Joaquin"
date: "10/8/2021"
output:
  pdf_document: default
  html_document: default
---

## R Markdown
```{r}
library(tidyverse)
library(ggpubr)
library(class)
library(caret)
library(e1071)
beers <- read_csv("https://raw.githubusercontent.com/BivinSadler/MSDS_6306_Doing-Data-Science/Master/Unit%208%20and%209%20Case%20Study%201/Beers.csv")
breweries <- read_csv("https://raw.githubusercontent.com/BivinSadler/MSDS_6306_Doing-Data-Science/Master/Unit%208%20and%209%20Case%20Study%201/Breweries.csv")

```

````{r}
##How many breweries are present in each state?
#This table outlines the quantity of breweries in each state and will be used as the basis of the following charts.
numbystate <- data.frame(breweries %>% count(State))
numbystate
numbystate$State <- as.factor(numbystate$State)

#bar graph depicting the number of breweries in each state
numbystate %>% ggplot(aes(x = reorder(State, n), y = n)) + 
  geom_segment(aes(xend=State, yend=0), color = 'grey50') + 
  geom_point(size=2, color="steelblue3") +
  coord_flip() +
  theme(legend.position = "none") +
  theme(axis.text.y = element_text(size = 6, color = "black")) +
  theme(panel.background = element_rect(fill = "white")) +
  theme(axis.ticks = element_line(size = .2)) +
  labs(x = "Count", y = "State") +
  ggtitle("Number of Breweries per State")

#Different chart (polar coordinates) giving a better visualization of relative amount of breweries in each state.
numbystate %>% ggplot(aes(x = State, y = n, fill = State)) + 
  geom_bar(stat = 'identity') + 
  coord_polar() + theme_bw() + 
  theme(legend.position = "none") + 
  labs(x = "State", y = "Count") + ggtitle("Number of Breweries per State")


## A more accurate representation of brewery density is depicted by determining Breweries per Capita
statepop <- get_acs(geography = 'state', variables = 	"B01003_001", year = 2019) %>% 
  cbind(data.frame(State = state.abb[match(statepop$NAME, state.name)])) %>% 
  mutate(population = estimate) %>% filter(!is.na(State)) %>% select(State, population)

#or alternatively (if without census API access)

statepop <- read_csv("https://raw.githubusercontent.com/j-dominguez9/Case-Study-1/main/statepop.csv")

#Join census data with previous table(numbystate)
breweriespercapita <- full_join(numbystate, statepop, by = "State") %>% 
  mutate(bpc = (n/population)*10000) %>% 
  mutate(State = as.factor(State))

#Plot 
breweriespercapita %>% filter(!is.na(population)) %>% filter(!State == "SD") %>% 
  ggplot(aes(x = reorder(State, bpc), y = bpc)) + 
  geom_segment(aes(xend=State, yend=0), color = 'grey50') + 
  geom_point(size=2, color="steelblue3") +
  coord_flip() +
  theme(legend.position = "none") +
  theme(axis.text.y = element_text(size = 7, color = "black")) +
  theme(panel.background = element_rect(fill = "white")) +
  theme(axis.ticks = element_line(size = .2)) +
  ggtitle("Breweries per Capita by State") +
  labs(x = "State", y = "Breweries per Capita (*10000)")

```


````{r}
##Address the missing values in each column.
sum(is.na(breweries))

#As we can see, the breweries data set holds no missing values, thus no need to eliminate any missing values.

sum(is.na(beers))

#The beers dataset has 1072, so we must eliminate noted values.

beers_clean <- beers %>% filter(!is.na(Name)) %>% filter(!is.na(Beer_ID)) %>% 
  filter(!is.na(ABV)) %>% filter(!is.na(IBU)) %>% 
  filter(!is.na(Brewery_id)) %>% filter(!is.na(Style)) %>% 
  filter(!is.na(Ounces))

#Removed 1007 rows due to missing values.

```


````{r}
##Compute the median alcohol content and international bitterness unit for each state. Plot a bar chart to compare.

#In order to join the two data sets successfully, we will need to find a primary key and a foreign key by which to join by. Let's examine the column names.

colnames(breweries)
colnames(beers_clean)

#As we can see, Brewery ID would be a good key to join them; however, we must make sure that they have a common spelling. Also, even though 'Name" makes sense for each respective dataset, we will need to change it in order to clarify what the column is indeed naming when joining.

breweries$Brewery = breweries$Name
breweries$Brewery_id = breweries$Brew_ID
head(breweries)

#Let's create a new dataframe with the relevant columns from 'breweries' before joining.

breweries_clean <- breweries %>% select(Brewery, City, State, Brewery_id)
join <- inner_join(breweries_clean, beers_clean, by = "Brewery_id")

#From the joined data frame, let's select the relevant columns.

medABVIBU <- join %>% select(State, ABV, IBU)
head(medABVIBU)

#Having the relevant columns to work with, lets create a new one with the median ABV of each state and call ot 'medABV'.
medABV <- medABVIBU %>% group_by(State) %>% mutate(medianABV = median(ABV)*100) %>% select(State, medianABV) %>% arrange(State) %>% distinct(State, medianABV)
head(medABV)
#As you can see, there is a row for every beer produced in each state. In order to plot the median correctly, we will need to delete duplicates so that we may only have one row (median) per state.



##Data set is now ready to plot.

medABV %>% ggplot(aes(x = reorder(State, medianABV), y = medianABV)) + 
geom_segment(aes(xend=State, yend=0), color = 'grey50') + 
  geom_point(size=2, color="steelblue3") +
  coord_flip() +
  theme(legend.position = "none") +
  theme(axis.text.y = element_text(size = 6, color = "black")) +
  theme(panel.background = element_rect(fill = "white")) +
  theme(axis.ticks = element_line(size = .2)) +
  labs(x = "State", y = "Median ABV") +
  ggtitle("Median ABV by State")

##We will follow a similar process to derive median IBU by State.

medIBU <- medABVIBU %>% 
  group_by(State) %>% 
  mutate(medianIBU = median(IBU)) %>% 
  select(State, medianIBU) %>% 
  arrange(State) %>% 
  distinct(State, medianIBU)

head(medIBU)

#And plot in a similar manner.

medIBU %>% ggplot(aes(x = reorder(State, medianIBU), y = medianIBU)) + 
 geom_segment(aes(xend=State, yend=0), color = 'grey50') + 
  geom_point(size=2, color="steelblue3") +
  coord_flip() +
  theme(legend.position = "none") +
  theme(axis.text.y = element_text(size = 6, color = "black")) +
  theme(panel.background = element_rect(fill = "white")) +
  theme(axis.ticks = element_line(size = .2)) +
  labs(x = "State", y = "Median IBU") +
  ggtitle("Median IBU by State")

```


````{r}
##Which state has the maximum alcoholic (ABV) beer? Which state has the most bitter (IBU) beer?

#We will create a new data frame with relevant columns to explore this question.
maxABVIBU <- join %>% select(Brewery, Name, State, ABV, IBU)

#We need to identify the highest ABV level
max(maxABVIBU$ABV)
maxABVIBU %>% filter(ABV == "0.125")

## We can see that the beer with the highest ABV belongs to the state of Kentucky (KY) with an ABV of 12.5. The beer is "London Balling" by Against the Grain Brewery.

#We follow the same process for IBU.
max(maxABVIBU$IBU)
maxABVIBU %>% filter(IBU == "138")

#The beer with the highest IBU belongs to the state of Oregon (OR) with an IBU of 138. The beer is "Bitter Bitch Imperial IPA" by Astoria Brewing Company.
```


````{r}
##Comment on the summary statistics and distribution of the ABV variable.
summary(maxABVIBU$ABV)


#Histogram
maxABVIBU %>% ggplot(aes(x = ABV)) + 
  geom_histogram(fill = "steelblue3") + 
  theme_classic() +
  labs(x = "ABV", y = "") +
  ggtitle("Distribution of ABV")

#Boxplot
maxABVIBU %>% ggplot(aes(x = ABV)) + 
  geom_boxplot(fill = "steelblue3") + 
  theme_classic() +
  labs(x = "ABV", y = "") +
  ggtitle("Distribution of ABV")
```


````{r}
##Is there an apparent relationship between the bitterness of the beer and its alcoholic content? Draw a scatter plot.  Make your best judgment of a relationship and EXPLAIN your answer.

#As we saw earlier, the distributions of both the IBU and ABV columns were right skewed, it'd be helpful to apply a log transformation before plotting. In the plot, we'd also like to include a linear regression line as well as its corresponding equation to better examine its relationship. 

maxABVIBU %>% ggplot(aes(x = log(ABV), y = IBU)) +
  geom_point(color = "steelblue3") +
  geom_smooth(method = "lm", color = "grey49") +
  stat_regline_equation() +
  theme_classic() +
  labs(x = "IBU", y = "ABV") +
  ggtitle("Relationship between IBU and ABV")

##From a visual inspection as well as a simple linear regression model, we can say that there is an apparent significant positive relationship between IBU and ABV (p-value = <.0001), with a 0.2-unit increase in ABV for every unit increase in IBU.

cor.test(x = log(maxABVIBU$ABV), y = maxABVIBU$IBU)

#This Pearson's correlation provides overwhelming evidence that there is a positive linear relationship (.67) between ABV and IBU (p-val = <.001).

```
 
 
```{r}
##Budweiser would also like to investigate the difference with respect to IBU and ABV between IPAs (India Pale Ales) and other types of Ale (any beer with “Ale” in its name other than IPA).  You decide to use KNN  classification to investigate this relationship.  Provide statistical evidence one way or the other. You can of course assume your audience is comfortable with percentages … KNN is very easy to understand conceptually. 

sum(grepl("Ale", join$Style))
sum(grepl("(India | IPA)", join$Style))

IPAs <- join %>% filter(grepl("(India | IPA)", Style))
Ales <- join %>% filter(grepl("Ale", Style)) %>% filter(!grepl("(India | IPA)", Style))

x <- data.frame(Group = "Ale", c(1:552)) %>% select(Group)
final_Ales <- cbind(x, Ales)

y <- data.frame(Group = "IPA", c(1:395)) %>% select(Group)
final_IPAs <- cbind(y, IPAs)

IPA_Ales <- full_join(final_IPAs, final_Ales) %>% filter(!grepl("Lager", Style))

IPA_Ales %>% ggplot(aes(x = IBU, y = ABV, color = Group)) + geom_point() + theme_bw() + ggtitle("Measuring ABV and IBU in IPAs and Ales")


confusionMatrix(table(knn.cv(IPA_Ales[,8:9], IPA_Ales$Group, k = 3), IPA_Ales$Group))

set.seed(1)
iterations = 500
numks = 50

masterAcc = matrix(nrow = iterations, ncol = numks)

for(j in 1:iterations)
{
  
  for(i in 1:numks)
  {
    CM = confusionMatrix(table(IPA_Ales$Group, knn.cv(IPA_Ales[,8:9], IPA_Ales$Group, k = i)))
    masterAcc[j,i] = CM$overall[1]
    
  }
  
}

MeanAcc = colMeans(masterAcc)

plot(seq(1,numks,1),MeanAcc, type = "l")

which.max(MeanAcc)
max(MeanAcc)

confusionMatrix(table(IPA_Ales$Group, knn.cv(IPA_Ales[,8:9], IPA_Ales$Group, k = 8)))

#Naive Bayes

nbIPA_Ales <- IPA_Ales %>% select(Group, ABV, IBU)
naiveBayes(Group~., data = nbIPA_Ales )


iterations = 100
masterAcc = matrix(nrow = iterations)
splitPerc = .8 #Training / Test split Percentage
for(j in 1:iterations)
{
  trainIndices = sample(1:dim(nbIPA_Ales)[1],round(splitPerc * dim(nbIPA_Ales)[1]))
  train = nbIPA_Ales[trainIndices,]
  test = nbIPA_Ales[-trainIndices,]
  model = naiveBayes(train[,2:3],train$Group)
  table(test$Group,predict(model,test[,2:3]))
  CM = confusionMatrix(table(test$Group,predict(model,test[,2:3])))
  masterAcc[j] = CM$overall[1]
}
MeanAcc = colMeans(masterAcc)
MeanAcc

### t-test
Ales_ABV <- final_Ales %>% select(ABV, Group)
IPAs_ABV <- final_IPAs %>% filter(!grepl("Lager", Style)) %>% select(ABV, Group)

ABVjoin <- full_join(Ales_ABV, IPAs_ABV)

t.test(ABV ~ Group, data = ABVjoin)

t.test(IBU ~ Group, data = IPA_Ales)

##NaiveBayes State, Style (IPA, Ales)

nb2 <- IPA_Ales %>% select(State, Group) %>% mutate(State = as.factor(State))
model <- naiveBayes(Group~., data = nb2)
model
predict(model, data.frame(State = "NH"), type = 'raw')


###NB State, City, Style (all)

df <- join %>% select(Style, City, State)
model <- naiveBayes(Style~., data = df)
predict(model, data.frame(State = "CO", City = "Buena Vista"))

###NB Find most popular Style by State
model <- naiveBayes(Style~State, data = df2)
model
predict(model, data.frame(State = "CO"))


### NB Find most popular City for Style

model <- naiveBayes(City~Style, data = df1)
pred <- predict(model, df1$Style)
confusionMatrix(as.factor(pred), as.factor(df1$City))
predict(model, data.frame(Style = "American IPA"))


###NB find most popular State for style

model <- naiveBayes(State~Style, data = df2)
pred <- predict(model, df2$Style)
confusionMatrix(as.factor(pred), as.factor(df2$State))
predict(model, data.frame(Style = "American IPA"))
```
 
 